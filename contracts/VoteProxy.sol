// VoteProxy - vote w/ a hot or cold wallet using a proxy identity
pragma solidity ^0.4.18;

import "./token.sol";
import "./chief.sol";

contract VoteProxy {
    address public cold;
    address public hot;
    address public self;
    DSToken public gov;
    DSToken public iou;
    DSChief public chief;

    constructor(DSChief _chief, address _cold, address _hot) public {
        chief = _chief;
        cold = _cold;
        hot = _hot;
        self = address(this);

        gov = chief.GOV();
        iou = chief.IOU();
        gov.approve(address(chief), uint256(-1));
        iou.approve(address(chief), uint256(-1));
    }

    modifier auth() {
        require(msg.sender == hot || msg.sender == cold, "Sender must be a Cold or Hot Wallet");
        _;
    }

    function lock(uint256 wad) public auth {
        gov.pull(hot, wad);   // mkr from cold
        chief.lock(wad);       // mkr out, ious in
    }

    function free(uint256 wad) public auth {
        chief.free(wad);       // ious out, mkr in
        gov.push(hot, wad);   // mkr to cold
    }

    function freeAll() public auth {
        chief.free(chief.deposits(address(this)));
        gov.push(hot, gov.balanceOf(address(this)));
    }

    function vote(address[] memory yays) public auth returns (bytes32) {
        return chief.vote(yays);
    }

    function vote(bytes32 slate) public auth {
        chief.vote(slate);
    }

}
